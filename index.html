<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <link href="https://cdn.bootcss.com/handsontable/3.0.0/handsontable.full.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/handsontable/3.0.0/handsontable.full.js"></script>
    <script src="https://cdn.bootcss.com/echarts/4.1.0.rc2/echarts.js"></script>
    <script src="createCharts.js"></script>
    <script src="shunting-yard-algorithm.js"></script>
    <link rel="stylesheet" type="text/css" href="./font/iconfont.css">
    <link rel="stylesheet" type="text/css" href="./style.css">

</head>
<body>
    <div class="tool-box">
      <select id="font-size">
        <option value="6px">6</option>
        <option value="8px">8</option>
        <option value="9px">9</option>
        <option value="10px">10</option>
        <option value="11px">11</option>
        <option value="12px">12</option>
        <option value="14px" selected>14</option>
        <option value="16px">16</option>
        <option value="18px">18</option>
        <option value="20px">20</option>
        <option value="22px">22</option>
        <option value="24px">24</option>
        <option value="26px">26</option>
        <option value="28px">28</option>
        <option value="36px">36</option>
        <option value="48px">48</option>
        <option value="72px">72</option>
      </select>
      <a id="font-size-plus">A<span class="upper">+</span></a>
      <a id="font-size-minus">A<span class="upper">-</span></a>
      <a id="font-color">A</a><!-- 
       --><div class="sub-panel">
        <div class="panel color-panel font-color-panel"></div>
      </div>
      <a id="font-background-color" class="iconfont icon-paintbucket"></a><!-- 
       --><div class="sub-panel">
        <div class="panel color-panel background-color-panel"></div>
      </div>

      <a id="font-bold">B</a>
      <a id="font-italic">I</a>
      <a id="font-underline">U</a>

      <a id="border" class="iconfont icon-borderall"></a><!-- 
       --><div class="sub-panel">
        <div class="panel border-panel">
          <div class="border iconfont icon-borderclear"></div>
          <div class="border iconfont icon-bordertop"></div>
          <div class="border iconfont icon-borderright"></div>
          <div class="border iconfont icon-borderbottom"></div>
          <div class="border iconfont icon-borderleft"></div>
          <div class="border iconfont icon-borderouter"></div>
          <div class="border iconfont icon-borderall"></div>
        </div>
      </div>
      <a id="border-color" class="iconfont icon-pen01"></a><!-- 
       --><div class="sub-panel">
        <div class="panel color-panel border-color-panel"></div>
      </div>

      <a id="text-align-left" class="iconfont icon-align-left"></a>
      <a id="text-align-center" class="iconfont icon-align-center"></a>
      <a id="text-align-right" class="iconfont icon-align-right"></a>

      <a id="merge" class="iconfont icon-mergecell"></a>
      <a id="unmerge" style="display: none;" class="iconfont icon-separatecell"></a>

      <a id="add-chart" class="iconfont icon-chartnew" onclick="addChart.toModal()"></a>
    </div>

    <input type="text" id="formulaEditor" style="width: 1000px">
    <div id="example"></div>

    <div id="addChartModal" class="modal">
      <div class="modal-header">
        <h3>添加图表</h3>
        <i class="iconfont icon-closel" onclick="addChart.clear();"></i>
      </div>
      <div class="modal-body">
        <div class="controls">
          <span class="controls-label">图表类型</span>
          <div class="controls-content">
            <select id="chart-type" onchange="addChart.changeChartType()">
              <option value="line" selected>折线图</option>
              <option value="bar">柱状图</option>
              <option value="pie">饼图</option>
            </select>
          </div>
        </div>
        <div class="controls">
          <span class="controls-label">x轴</span>
          <div class="controls-content">
            <input onclick="addChart.onAxisClick('x', 0)" class="xAxis">
          </div>
        </div>
        <div class="controls">
          <span class="controls-label">y轴</span>
          <div class="controls-content">
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button onclick="addChart.execute();">确认</button>
        <button onclick="addChart.clear();">取消</button>
      </div>
    </div>

    <script>
        function ReportEditor () {
          this.tableWidth = 26
          this.tableHeight = 100
          this.tabelHeaderHeight = 0
          this.tableHeaderData = []
          this.tableBodyData = []
          this.styleList = {}
          this.customRowHeight = []
          this.customColWidth = []
          this.formulaList = []
          this.paramList = []
          this.mergeCells = []
          this.cellReference = []
          this.afterSelectionCallbackList = {}
        }
        ReportEditor.prototype = {
          // 获取某个单元格的DOM
          getCell (row, col) {
            return this.hot.getCell(row, col)
          },

          /**
           * 判断某一个单元格是否是被合并的
           * 如果是合并单元格左上角那个一就返回{colspan, rowspan}
           * 如果是合并的但不是左上角就返回true
           * 否则返回false
           * @Author   chenht
           * @DateTime 2018-06-14
           */
          isInMerged (row, col) {
            var inside = false
            this.hot.getPlugin('mergeCells').mergedCellsCollection.mergedCells.forEach(v => {
              if (col >= v.col && 
                (col <= v.col + v.colspan - 1) &&
                row >= v.row &&
                (row <= v.row + v.rowspan - 1)) {
                if (col !== v.col || row !== v.row) {
                  inside = true
                } else {            
                  inside = {
                    colspan: v.colspan,
                    rowspan: v.rowspan
                  };
                }
              }
            })
            return inside
          },
          /**
           * 返回该单元格被合并之后,合并结果的左上角那一个的坐标.
           * @Author   chenht
           * @DateTime 2018-06-14
           * @return   {col, row}
           */
          getMergedHead (row, col) {
            var mergedCells = this.hot.getPlugin('mergeCells').mergedCellsCollection.mergedCells;
            for (var i = 0; i < mergedCells.length; i++) {
              var v = mergedCells[i];
              if (col >= v.col && 
                (col <= v.col + v.colspan - 1) &&
                row >= v.row &&
                (row <= v.row + v.rowspan - 1)) {
                return v;
              }
            }
          },
          /**
           * 遍历所有被选中的单元格
           * @Author   chenht
           * @DateTime 2018-06-14
           * option{
           *   skipMergedCell: 当为真时,只在非merge的单元格执行回调
           * } 
           */
          traversalSelectedCell (callback, options) {
            options = options || {}
            // 获取被选中的单元格组
            var selected = this.hot.getSelected();
            if (!selected) { return; }
            // 遍历每个组
            for (var i = 0; i < selected.length; i++) { 
              // 获取该组的左上角坐标(min)和右下角坐标(max)
              min = [Math.min(selected[i][0], selected[i][2]), Math.min(selected[i][1], selected[i][3])];
              max = [Math.max(selected[i][0], selected[i][2]), Math.max(selected[i][1], selected[i][3])];
              // 通过min和max遍历一个矩形
              for (var row = min[0]; row <= max[0]; row++) {
                for (var col = min[1]; col <= max[1]; col++) {
                  // 判断该格是否是顶部/最左边/底部/最右边
                  var param = {
                    isTop: row === min[0],
                    isRight: col === max[1],
                    isBottom: row === max[0],
                    isLeft: col === min[1]
                  }
                  // 如果参数中有skipMergedCell则判读是否是合并单元格中.
                  if (options.skipMergedCell) {
                    var inside = this.isInMerged(row, col)
                    if (!inside) {
                      callback(row, col, param);
                    } else if (inside.rowspan) {
                      // 如果合并单元格的左上角,则改变param的参数
                      param.merged = true;
                      param.rowspan = inside.rowspan;
                      param.colspan = inside.colspan;
                      param.isRight = col + inside.colspan - 1 === max[1];
                      param.isBottom = row + inside.rowspan - 1 === max[0];
                      callback(row, col, param);
                    }
                  } else {
                    callback(row, col, param);
                  }
                }
              }
            }
          },
          /**
           * 设置样式
           * @Author   chenht
           * @DateTime 2018-06-14
           * @param    {object}   style (标准的sytle对象)
           */
          setStyle (style) {
            this.traversalSelectedCell((row, col) => {
              // 遍历选中的单元格,设置样式.
              if (!this.styleList[row + ',' + col]) { this.styleList[row + ',' + col] = {}; }
              
              for (var key in style) {
                this.styleList[row + ',' + col][key] = style[key]
              }
            })
            // 重新渲染表格
            this.hot.render();
          },
          /**
           * 设置边框
           * @Author   chenht
           * @DateTime 2018-06-14
           * @param    {object}   border {
           *                        type: Number (边框类型c框),
           *                        color: String (颜色)
           *                      }
           */
          setBorder (border) {
            // 新建某个单元格的样式(没有的话)
            var hasStyle = (row, col) => {
              if (!this.styleList[row + ',' + col]) { this.styleList[row + ',' + col] = {}; }
              return true;
            }

            // 将合并单元格的样式代码抽出来的方法
            // 比如我要设置上边框,但是上面是一个合并了的单元格,那么就应该设置这个合并的单元格的下边框
            var setMergedBorder = (row, col, css, color) => {
              var inside = this.isInMerged(row, col);
              if (inside === true) {
                // 计算并替换成该合并单元格的左上角的坐标
                var mergedHead = this.getMergedHead(row, col);
                row = mergedHead.row;
                col = mergedHead.col;
              } 

              if (color) {
                hasStyle(row, col);
                this.styleList[row + ',' + col][css] = color
              } else if (this.styleList[row + ',' + col]) {
                delete this.styleList[row + ',' + col][css]
              }
            }

            // if (this.hot.getSelected().length > 1) { return; }
            
            // 遍历被选择的单元格设置样式
            this.traversalSelectedCell((row, col, param) => {
              // 清除边框和设置所有边框的情况
              if (border.type === 0 || border.type === 6) {
                // 所选区域的第一行且不是整个表的第一行:
                if (param.isTop && row > 0 && (border.type === 0 ? this.styleList[(row - 1) + ',' + col] : hasStyle((row - 1), col))) {
                  setMergedBorder(row - 1, col, 'borderBottomColor', border.type === 6 && border.color);
                }
                // 所选区域的第一列且不是A列:
                if (param.isLeft && col > 0 && (border.type === 0 ? this.styleList[row + ',' + (col - 1)] : hasStyle(row, col - 1))) {
                  setMergedBorder(row, col - 1, 'borderRightColor', border.type === 6 && border.color);
                }
                // A列
                if (col === 0 && (border.type === 0 ? this.styleList[row + ',' + col] : hasStyle(row, col))) {
                  if (border.type === 0) {
                    delete this.styleList[row + ',' + col].borderLeftColor
                  } else {
                    this.styleList[row + ',' + col].borderLeftColor = border.color
                  }
                }
                // 整个表的第一行
                if (row === 0 && (border.type === 0 ? this.styleList[row + ',' + col] : hasStyle(row, col))) {
                  if (border.type === 0) {
                    delete this.styleList[row + ',' + col].borderTopColor
                  } else {
                    this.styleList[row + ',' + col].borderTopColor = border.color
                  }
                }
                // 其他的项  
                if (border.type === 0 ? this.styleList[row + ',' + col] : hasStyle(row, col)) {
                  if (border.type === 0) {
                    delete this.styleList[row + ',' + col].borderRightColor
                    delete this.styleList[row + ',' + col].borderBottomColor
                  } else {
                    this.styleList[row + ',' + col].borderRightColor = border.color
                    this.styleList[row + ',' + col].borderBottomColor = border.color
                  }
                }
              }
              else {
                  // 上边框或者周围边框
                  if ((border.type === 1 || border.type === 5) && param.isTop) {
                      for (var i = 0; i < (param.colspan || 1); i++) {
                        if (row > 0) {
                            setMergedBorder(row - 1, (col + i), 'borderBottomColor', border.color);
                        } else {
                            hasStyle(row, (col + i))
                            this.styleList[row + ',' + (col + i)].borderTopColor = border.color
                        }
                      }
                  }
                  // 右边框或者周围边框
                  if ((border.type === 2 || border.type === 5) && param.isRight) {
                    hasStyle(row, col)
                    this.styleList[row + ',' + col].borderRightColor = border.color
                  }
                  // 下边框或者周围边框
                  if ((border.type === 3 || border.type === 5) && param.isBottom) {
                    hasStyle(row, col)
                    this.styleList[row + ',' + col].borderBottomColor = border.color
                  }
                  // 左边框或者周围边框
                  if ((border.type === 4 || border.type === 5) && param.isLeft) {
                      for (var i = 0; i < (param.rowspan || 1); i++) {
                        if (col > 0) {
                            setMergedBorder((row + i), col - 1, 'borderRightColor', border.color);
                        } else {
                            hasStyle((row + i), col)
                            this.styleList[(row + i) + ',' + col].borderLeftColor = border.color
                        }
                      }
                  }
              }
            }, {skipMergedCell: true})
            this.hot.render();
          },
          /**
           * 获取当前选中的单元格的样式
           * @Author   chenht
           * @DateTime 2018-09-12
           */
          getSelectedStyle () {
            var style = {}
            var styleNameList = ['fontSize', 'color', 'background', 'fontWeight', 'fontStyle', 'textDecoration', 'textAlign'];
            var defaultValue = {
              fontSize: '14px',
              color: '#000000',
              background: '#ffffff',
              fontWeight: 'normal',
              fontStyle: 'normal',
              textDecoration: 'none',
              textAlign: 'left'
            }
            styleNameList.forEach(v => style[v] = null);
            function compareColor (v1, v2) {
              v1 = v1.substr(1);
              v2 = v2.substr(1);
              if (v1.length === 3) {
                v1 = v1.split('');
                v1[5] = v1[4] = v1[2];
                v1[3] = v1[2] = v1[1];
                v1[1] = v1[0];
                v1 = v1.join('');
              }
              if (v2.length === 3) {
                v2 = v2.split('');
                v2[5] = v2[4] = v2[2];
                v2[3] = v2[2] = v2[1];
                v2[1] = v2[0];
                v2 = v2.join('');
              }
              return v1.toLowerCase() === v2.toLowerCase();
            }

            function compareStyle (name, v1, v2) {
              v2 = v2 || defaultValue[name];
              switch (name) {
                case 'fontSize': {
                  return parseFloat(v1) === parseFloat(v2);
                }
                case 'color': {
                  return compareColor(v1, v2);
                }
                case 'background': {
                  return compareColor(v1, v2);
                }
                case 'fontWeight': {
                  return v1 === v2;
                }
                case 'fontStyle': {
                  return v1 === v2;
                }
                case 'textDecoration': {
                  return v1 === v2;
                }
                case 'textAlign': {
                  return v1 === v2;
                }
              }
            }
            this.traversalSelectedCell((row, col, param) => {
              var s = this.styleList[row + ',' + col];
              if (!s) { return; }

              styleNameList.forEach(v => {
                if (style[v] === null) {
                  if (s[v]) {
                    style[v] = s[v];
                  }
                } else {
                  if (style[v] && !compareStyle(v, style[v], s[v])) {
                    delete style[v];
                  }
                }
              });
            });
            styleNameList.forEach(v => {
              style[v] = style[v] !== null ? style[v] : defaultValue[v];
            })
            return style;
          },
          /**
           * 在读取时填充空白的data
           * 比如1行填充到20行
           * @Author   chenht
           * @DateTime 2018-06-14
           */
          fillEmptyData (data, width, height) {
            data = data.concat(new Array(height).join('.').split('.').map(v => []).slice(0, height));
            return data;
          },
          /**
           * 删除空白行  
           * 传入的data是一个wdith*height的二维数组 
           * 最后要返回尽量少的数据. 
           * 具体就是把有数据的最后一行后面的行删掉 
           * 同一行里，把有数据的最后一个后面的删掉. 
           * @Author   chenht
           * @DateTime 2018-06-14
           */
          arrayTrim (data) {
            var hasDataToken = false;
            // 倒序
            for (var i = data.length - 1; i >= 0; i--) {
              if (data[i].some(v => v)) { 
                hasDataToken = true;
                for (var j = data[i].length - 1; j > 0; j--) {
                  if (data[i][j]) { break; }
                  data[i].splice(j, 1);
                }
                continue; 
              }
              // 到这里肯定是一个空行
              // 已经是有数据的最后一行上面的话置空
              if (hasDataToken) {
                data[i].length = 0;
              } else { // 否则删掉这一行
                data.length --;
              }
            }
          },
          /**
           * 获取公式列表
           * @Author   chenht
           * @DateTime 2018-06-14
           */
          getFormulas (array) {
            var formulaList = [];
            // 遍历每个有数据的单元格，
            array.forEach((v, i) => {
              v.forEach((u, j) => {
                // 筛选{{=....}}这样的东西
                if (/^{{=.*}}$/.test(u)) {
                  var rawFormula = u.match(/^{{=(.*)}}$/)[1];
                  // 通过算法计算出逆波兰表达式
                  formulaList.push({pos: i + ',' + j, formula: sya(rawFormula)});
                }
              })
            })
            return formulaList;
          },
          /**
           * 获取用到的后台查询表达式列表
           * 即从公式列表中筛选出type为e（expression）的表达式
           * @Author   chenht
           * @DateTime 2018-06-14
           */
          getParamList (formulaList) {
            var paramList = [];
            formulaList.forEach(v => {
              v.formula.forEach(u => {
                if (u.type === 'e') {
                  paramList.push(u.value)
                }
              })
            })
            return paramList;
          },
          /**
           * 将直角坐标系转化为excel坐标 (0,0) => A1
           * @Author   chenht
           * @DateTime 2018-06-14
           */
          cartesianToExcelCoord (row, col) {
            function mod26 (num) {
              return num % 26 === 0 ? 26 : num % 26;
            }
            row += 1;
            col += 1;
            var _col = '';
            while (col) {
              _col = String.fromCharCode(mod26(col) + 64) + _col;
              col = (col - mod26(col)) / 26
            }
            return _col + row;
          },
          /**
           * 将excel坐标转化为直角坐标系 A1 => (0,0)
           * @Author   chenht
           * @DateTime 2018-06-14
           */
          excelCoordToCartesian (coord) {
            var col = coord.match(/[A-Z]{1,}/)[0];
            col = col.split('').map(v => v.charCodeAt() - 64).reduce((o, n) => o * 26 + n, 0) - 1
            var row = +coord.match(/[0-9]{1,}/)[0] - 1
            return [row, col]
          },
          /**
           * 获取选中的单元格的excel坐标
           * @Author   chenht
           * @DateTime 2018-06-14
           */
          getSelectedCellCoord () {
            var coordList = [];
            this.traversalSelectedCell((row, col) => {
              var coord = this.cartesianToExcelCoord(row, col);
              coordList.push(coord);
            }, {skipMergedCell: true})
            document.getElementById('formulaEditor').value = coordList.join(',');
            return coordList;
          },
          /**
           * 计算该单元格所引用的单元格列表
           * @Author   chenht
           * @DateTime 2018-06-14
           */
          checkReference () {
            var selected = this.hot.getSelected()[0];

            if (!selected) { return; }
            var data = this.hot.getData(selected[0], selected[1], selected[0], selected[1])[0][0]
            var coords = data.match(/[A-Z]+[0-9]+/g);
            this.cellReference = coords ? coords.map(v => this.excelCoordToCartesian(v)) : [];
            this.hot.render();
          },
          /**
           * 获取所有单元格的应用列表
           * 返回一个数组: [{ name: 'A1', children: ['A2', 'A3'] }]
           * @Author   chenht
           * @DateTime 2018-06-14
           */
          getReferenceCellsList (data) {
            var referenceCellsList = []
            data.forEach((v, row) => {
              v && v.forEach((u, col) => {
                if (!/^{{=.*}}$/.test(u)) { return; }
                u = u.replace(/\$\([\s\S]*?\)/g, '');
                var cells = u.match(/[A-Z]+[0-9]+/g);
                if (cells) {
                    referenceCellsList.push({
                        name: this.cartesianToExcelCoord(row, col),
                        children: cells
                    })
                }
              })
            })
            return referenceCellsList;
          },
          /**
           * 深度优先搜索,判断是否存在循环引用
           * 参数是getReferenceCellsList方法返回的列表
           * @Author   chenht
           * @DateTime 2018-06-14
           */
          depthFirstSearch (list) {
            var listReserved = Object.assign([], list);
            // 栈保存了需要遍历的节点
            var stack = [];
            // 队列保存了现在遍历的路径
            var queue = [];
            // 只要列表中有没有访问过的节点就继续循环
            while (list.some(v => !v.visited)) {
              // 拿一个未访问过的节点,并压入栈
              var firstNode = list.find(v => !v.visited);
              stack.push(firstNode);

              while (stack.length > 0) {
                // 如果栈顶为空则从队列中弹出一个元素
                var curNode = stack.pop();
                if (!curNode) {
                  queue.pop();
                  continue;
                }
                // 遍历一个节点则向栈中压入一个null
                // 用于连续回退时缩短queue
                stack.push(null);
                var index = queue.indexOf(curNode);
                queue.push(curNode); // 同时把当前的节点压入queue
                // 如果queue中已经有了当前节点则形成闭环,即循环调用.
                if (index > -1) {
                  console.error('有闭环:' + queue.filter((v, i) => i >= index).map(v => v.name).join('->'));
                  return false;
                }
                curNode.visited = true;
                if (curNode.children) {
                  // 将儿子压入栈
                  var children = curNode.children.map(v => list.find(u => u.name === v)).filter(v => v);
                  if (children.length > 0) {
                    stack = stack.concat(children)
                  }
                }
              }
            }
            return true;
          },    
          /**
           * 有向图的拓扑排序,产生一个不会发生死锁的资源获取队列
           * 参数是getReferenceCellsList方法返回的列表
           * @Author   chenht
           * @DateTime 2018-06-14
           */
          topoSort (list) {
            list.forEach(v => v.out = []);
            list.forEach(v => {
              //  计算每一个节点的出度和入度
              //  出度out是有哪些节点依赖该节点
              //  入度in是该节点依赖哪些节点 即 children
              var children = v.children.map(w => list.find(u => u.name === w)).filter(w => w);
              v.in = children;
              children.forEach(u => u.out.push(v))
            })

            var result = [];
            while (list.length > 0) {
              // 选择一个入度为0的
              var curNode = list.find(v => v.in.length === 0)
              // 压入结果集, 删除出度对应节点的 对于该节点的 入度(删除该节点和子节点的弧)
              result.push(curNode);
              list.splice(list.indexOf(curNode), 1)
              curNode.out.forEach(v => {
                v.in.splice(v.in.indexOf(curNode), 1)
              })
            }
            return result;
          },
          /**
           * 保存表格
           * @Author   chenht
           * @DateTime 2018-06-14
           */
          save () {
            var {tableWidth, tableHeight, tabelHeaderHeight, styleList, customColWidth, customRowWidth} = this;
            var saveData = {tableWidth, tableHeight, tabelHeaderHeight, styleList, customColWidth, customRowWidth};

            // 保存合并的单元格
            saveData.mergeCells = this.hot.getPlugin('mergeCells').mergedCellsCollection.mergedCells;
            saveData.mergeCells = saveData.mergeCells.map(v => ({
              col: v.col,
              colspan: v.colspan,
              row: v.row,
              rowspan: v.rowspan
            }));

            saveData.tableHeaderData = tabelHeaderHeight > 0 ? this.hot.getData(0, 0, tabelHeaderHeight - 1, tableWidth - 1) : [];
            saveData.tableBodyData = this.hot.getData(tabelHeaderHeight, 0, tableHeight - 1, tableWidth - 1);
            
            // 删除数据的空白部分
            this.arrayTrim(saveData.tableHeaderData);
            this.arrayTrim(saveData.tableBodyData);

            var referenceCellsList = this.getReferenceCellsList(Object.assign([], saveData.tableHeaderData, saveData.tableBodyData));
            // 判断是否有循环引用
            if (!this.depthFirstSearch(referenceCellsList)) { return; }

            // 拓扑排序队列
            var topoSortList = this.topoSort(referenceCellsList).map(v => {
              var coord = this.excelCoordToCartesian(v.name)
              return coord[0] + ',' + coord[1];
            });

            // 对拓扑排序队列中的单元格单独排序,放在公式列表的最后.
            saveData.formulaList = this.getFormulas(saveData.tableBodyData);
            saveData.paramList = this.getParamList(saveData.formulaList);

            var sortedFormula = saveData.formulaList.filter(v => topoSortList.find(u => u === v.pos));
            sortedFormula.forEach(v => {
              saveData.formulaList.splice(saveData.formulaList.indexOf(v), 1)
            })

            sortedFormula.sort((a, b) => {
                var posA = topoSortList.findIndex(v => v === a.pos);
                var posB = topoSortList.findIndex(v => v === b.pos);
                return posA - posB;
            })
            // 将公式中的excel坐标系转换成直角坐标系
            sortedFormula.forEach(w => {
              w.formula.forEach(v => {
                if (v.type !== 'c') { return; }
                var coord = this.excelCoordToCartesian(v.value)
                v.value = coord[0] + ',' + coord[1];
              })
            })
            saveData.formulaList = saveData.formulaList.concat(sortedFormula);

            // 保存自定义的行高和列宽
            saveData.customRowHeight = [];
            saveData.customColWidth = [];
            for (var i = 0; i < saveData.tableHeight; i++) {
              var height = this.hot.getRowHeight(i);
              if (height !== 23) {
                saveData.customRowHeight.push([i, height])
              }
            }
            for (i = 0; i < saveData.tableWidth; i++) {
              var width = this.hot.getColWidth(i)
              if (width !== 105) {
                saveData.customColWidth.push([i, width])
              }
            }


            localStorage.setItem('report', JSON.stringify(saveData))
          },          
          load () {
            var report = JSON.parse(localStorage.getItem('report'));
            Object.assign(this, report || {})

            this.hot = Handsontable(document.getElementById('example'), {
              data: this.fillEmptyData(this.tableHeaderData.concat(this.tableBodyData), this.tableWidth, this.tableHeight),
              height: 456,
              colWidths: new Array(this.tableWidth).join('.').split('.').map((v, i) => { var item = this.customColWidth.find(u => u[0] === i); return item ? item[1] : 105 }),
              rowHeights: new Array(this.tableHeight).join('.').split('.').map((v, i) => { var item = this.customRowHeight.find(u => u[0] === i); return item ? item[1] : 23 }),
              minCols: this.tableWidth,
              minRows: this.tableHeight,
              rowHeaders: true,
              colHeaders: true,
              filters: true,
              dropdownMenu: true,
              contextMenu: {
                callback: function (key, options) {
                  if (key === 'about') {

                  }
                },
                items: {
                  row_above: {},
                  row_below: {},
                  hsep1: '---------',
                  col_left: {},
                  col_right: {},
                  hsep2: '---------',
                  remove_row: {},
                  remove_col: {},
                  hsep3: '---------',
                  undo: {},
                  redo: {},
                  make_read_only: {},
                  mergeCells: {},
                  about: {name: 'about'}
                }
              },
              // autoRowSize: true,
              manualColumnMove: true,
              manualRowMove: true,
              manualColumnResize: true,
              mergeCells: this.mergeCells,
              manualRowResize: true,
              fillHandle: {
                autoInsertRow: false,
              },
              cells: (row, column) => {
                var cellMeta = {};
                  var getStyle = (row, col, styleName) => {
                    return this.styleList[row + ',' + col] && this.styleList[row + ',' + col][styleName]
                  }
                  cellMeta.renderer = (hotInstance, TD, row, col, prop, value) => {
                    TD.style.color = getStyle(row, col, 'color') || '#000';
                    TD.style.backgroundColor = getStyle(row, col, 'background') || '#fff';
                    TD.style.fontSize = getStyle(row, col, 'fontSize') || '14px';
                    TD.style.fontWeight = getStyle(row, col, 'fontWeight') || 'normal';
                    TD.style.fontStyle = getStyle(row, col, 'fontStyle') || 'normal';
                    TD.style.textAlign = getStyle(row, col, 'textAlign') || 'left';
                    TD.style.textDecoration = getStyle(row, col, 'textDecoration') || 'none';
                    TD.style.borderTopColor = getStyle(row, col, 'borderTopColor') || ""
                    TD.style.borderLeftColor = getStyle(row, col, 'borderLeftColor') || ""
                    TD.style.borderBottomColor = getStyle(row, col, 'borderBottomColor') || ""
                    TD.style.borderRightColor = getStyle(row, col, 'borderRightColor') || ""

                    if (this.cellReference) {
                      if (this.cellReference.find(v => (v[0] === row && v[1] === col))) {
                        TD.style.backgroundColor = 'red';
                      }
                    }
                    TD.textContent = value;
                  };


                return cellMeta;
              },
              afterSelection: (r, c, r2, c2, preventScrolling, selectionLayerLevel) => {
                // console.log(r, c, r2, c2, preventScrolling, selectionLayerLevel);
                var selectedCells = this.getSelectedCellCoord();
                var style = this.getSelectedStyle();
                var firstSelected = selectedCells.length && this.hot.getSelected()[0];
                if (style) {
                  toolBox.fontSize = style.fontSize;
                  toolBox.fontBold = style.fontWeight === 'bold';
                  toolBox.fontItalic = style.fontStyle === 'italic';
                  toolBox.textUnderline = style.textDecoration === 'underline';
                  toolBox.textAlign = style.textAlign;
                }
                toolBox.showUnmerge = selectedCells.length === 1 && (firstSelected[2] !== firstSelected[0] || firstSelected[3] !== firstSelected[1]);
                toolBox.showMerge = selectedCells.length > 0 && !toolBox.showUnmerge;
                toolBox.rerender();

                for (var key in this.afterSelectionCallbackList) {
                  this.afterSelectionCallbackList[key]();
                }
              }
            });
          }
        }

        var reportEditor = new ReportEditor();
        reportEditor.load();

        // 初始化工具条

        var toolBox = {
          fontSize: '14px',
          background: '#ffffff',
          color: '#000000',
          borderColor: '#000000',
          border: 6,
          fontBold: false,
          fontItalic: false,
          showMerge: true,
          showUnmerge: false,
          textAlign: 'left',

          setColor (e) {
            e.stopPropagation();
            reportEditor.setStyle({color: this.color});
          },
          setBackground (e) {
            e.stopPropagation();
            reportEditor.setStyle({background: this.background});
          },
          setfontSize () {
            reportEditor.setStyle({fontSize: this.fontSize});
          },
          setFontWeight () {
            reportEditor.setStyle({fontWeight: this.fontBold ? 'normal' : 'bold'});
            this.fontBold = !this.fontBold;
          },
          setFontStyle () {
            reportEditor.setStyle({fontStyle: this.fontItalic ? 'normal' : 'italic'});
            this.fontItalic = !this.fontItalic;
          },
          setTextDecoration () {
            reportEditor.setStyle({textDecoration: this.textUnderline ? 'none' : 'underline'});
            this.textUnderline = !this.textUnderline;
          },
          setTextAlign () {
            reportEditor.setStyle({textAlign: this.textAlign});
          },
          setBorder (e) {
            e.stopPropagation();
            reportEditor.setBorder({type: this.border, color: this.borderColor});
          },
          rerender () {       
            var borderClassNameList = ['clear', 'top', 'right', 'bottom', 'left', 'outer', 'all'];

            $('#border')[0].className = 'iconfont icon-border' + borderClassNameList[this.border];
            $('#font-color')[0].style = 'border-color:' + this.color;
            $('#font-background-color')[0].style = 'border-color:' + this.background;
            $('#border-color')[0].style = 'border-color:' + this.borderColor;
            $('#border-color')[0].style = 'border-color:' + this.borderColor;
            $('#font-size')[0].value = this.fontSize;
            $('#merge')[0].style = this.showMerge ? 'display:inline-block' : 'display:none';
            $('#unmerge')[0].style = this.showUnmerge ? 'display:inline-block' : 'display:none';

            $('#font-bold')[0].className = this.fontBold ? 'active' : '';
            $('#font-italic')[0].className = this.fontItalic ? 'active' : '';
            $('#font-underline')[0].className = this.textUnderline ? 'active' : '';

            $('#text-align-left')[0].className = (this.textAlign === 'left' ? 'active' : '') + ' iconfont icon-align-left';
            $('#text-align-center')[0].className = (this.textAlign === 'center' ? 'active' : '') + ' iconfont icon-align-center';
            $('#text-align-right')[0].className = (this.textAlign === 'right' ? 'active' : '') + ' iconfont icon-align-right';
          },
          colorClickHandlerBuilder (dom) {
            var type = dom;
            var type = '';
            if (dom.className.indexOf('font-color-panel') > -1) { type = 'color'; }
            if (dom.className.indexOf('background-color-panel') > -1) { type = 'background'; }
            if (dom.className.indexOf('border-color-panel') > -1) { type = 'borderColor'; }

            return function (e) {
              toolBox[type] = '#' + e.target.color;
              dom.style = 'display:none';
              setTimeout(function() {
                dom.style = '';
              }, 500);
              toolBox.rerender();

              switch (type) {
                case 'color': { toolBox.setColor(e); return; }
                case 'background': { toolBox.setBackground(e); return; }
                case 'borderColor': { toolBox.setBorder(e); return; }
              }
            }
          }
        }

        var defaultColorList = 
          ['FFFFFF', '000000', 'D6D5D5', '415065', '5792C6', 'DC772E', '9B9B9B', 'EBB305', '416DB7', '6BA243',
           'DFDFDF', '787878', 'C2C0C0', 'C7CCD4', 'D2D4D6', 'E7D4C6', 'DCDCDC', 'EBDFBE', 'CAD2E0', 'D2DDCA',
           'C9C9C9', '545454', 'A3A0A0', 'A2ADBC', 'B0C8DD', 'E4BDA1', 'CBCBCB', 'EAD490', 'A8B8D6', 'B8D0A7',
           'B2B2B2', '3C3C3C', '6F6B6B', '7D8DA5', '93B6D4', 'E1A67C', 'BBBBBB', 'EBCA60', '869FCB', '9DC285',
           '9B9B9B', '232323', '373535', '2E3C4B', '2B6FA9', 'B8560D', '757575', 'B28805', '345220', '4F7A32',
           '787878', '090909', '131212', '1E2632', '1B4A73', '7C3808', '4E4E4E', '785C05', '1C355F', '345220',
           'C00000', 'FF0000', 'FFC000', 'FFFF00', '92D050', '00B050', '00B0F0', '0070C0', '002060', '7030A0']
        var $ = document.querySelectorAll.bind(document);
        $('.color-panel').forEach(v => {
          var clickHandler = toolBox.colorClickHandlerBuilder(v);
          defaultColorList.forEach(u => {
            var color = document.createElement('div');
            color.className = 'color';
            color.color = u;
            color.style = "background: #" + u;
            color.addEventListener('click', clickHandler);
            v.append(color);
          })
        })

        $('.border-panel .border').forEach((v, i) => {
          v.addEventListener('click', function (e) {
            v.parentNode.style = 'display:none';
            setTimeout(function() {
              v.parentNode.style = '';
            }, 500);
            toolBox.rerender();
            toolBox.border = i;
            toolBox.rerender();
            toolBox.setBorder(e);
          })
        })
        $('#font-size')[0].addEventListener('change', e => {
          toolBox.fontSize = $('#font-size')[0].value;
          toolBox.setfontSize();
        })

        $('#font-color')[0].addEventListener('click', toolBox.setColor.bind(toolBox));
        $('#font-background-color')[0].addEventListener('click', toolBox.setBackground.bind(toolBox));
        $('#border-color')[0].addEventListener('click', toolBox.setfontSize.bind(toolBox));
        $('#border')[0].addEventListener('click', toolBox.setBorder.bind(toolBox));

        $('#merge')[0].addEventListener('click', e => {
          reportEditor.hot.getPlugin('mergeCells').toggleMerge(reportEditor.hot.getSelectedRange()[0]);
        })
        $('#unmerge')[0].addEventListener('click', e => {
          reportEditor.hot.getPlugin('mergeCells').toggleMerge(reportEditor.hot.getSelectedRange()[0]);
        })
        $('#font-bold')[0].addEventListener('click', e => {
          toolBox.setFontWeight();
          toolBox.rerender();
        })
        $('#font-italic')[0].addEventListener('click', e => {
          toolBox.setFontStyle();
          toolBox.rerender();
        })
        $('#font-underline')[0].addEventListener('click', e => {
          toolBox.setTextDecoration();
          toolBox.rerender();
        })
        $('#text-align-left')[0].addEventListener('click', e => {
          toolBox.textAlign = 'left';
          toolBox.setTextAlign();
          toolBox.rerender();
        })
        $('#text-align-center')[0].addEventListener('click', e => {
          toolBox.textAlign = 'center';
          toolBox.setTextAlign();
          toolBox.rerender();
        })
        $('#text-align-right')[0].addEventListener('click', e => {
          toolBox.textAlign = 'right';
          toolBox.setTextAlign();
          toolBox.rerender();
        })

        $('.tool-box')[0].addEventListener('mousedown', e => e.stopPropagation());

        toolBox.rerender();


        // 模态框初始化
        $('.modal').forEach(v => {
          var header = v.querySelector('.modal-header');

          var offset = {};
          var isMousedown = false;
          header.addEventListener('mousedown', e => {
            offset.x = e.clientX - v.offsetLeft;
            offset.y = e.clientY - v.offsetTop;
            isMousedown = true;
          })
          document.addEventListener('mousemove', e => {
            if (!isMousedown) {return}
            var pos = {
              x: e.clientX - offset.x,
              y: e.clientY - offset.y
            }
            v.style.left = Math.min(window.innerWidth - 600, Math.max(0, pos.x)) + 300 + 'px';
            v.style.top = Math.min(window.innerHeight - v.offsetHeight, Math.max(0, pos.y)) + 'px';
          })
          document.addEventListener('mouseup', e => {
            isMousedown = false;
          })
        });

        var addChart = {
          yAxisCount: 0,
          toModal () {
            reportEditor.afterSelectionCallbackList.chartAxisClick = e => {
              if (!this.currentAxis) { return; }
              var input = $('#addChartModal .modal-body .' + this.currentAxis[0] + 'Axis')[this.currentAxis[1]];
              input.value = reportEditor.getSelectedCellCoord()
              $('#addChartModal input').forEach(v => v.className = v.className.replace(/active/g, ''));
              console.log(this.currentAxis);
            }
            this.addAxisY();
            $('#addChartModal')[0].style="display:block";
          },
          execute () {
            chart.create($('#addChartModal select')[0].value)
            addChart.clear();
          },
          clear () {
            delete reportEditor.afterSelectionCallbackList.chartAxisClick;
            $('#addChartModal')[0].style="";
            $('#addChartModal input').forEach(v => v.value = '');
            $('#addChartModal .item').forEach(v => v.remove());
            $('#addChartModal select')[0].value = 'line';
            $('#addChartModal .controls')[2].style = '';
          },
          addAxisY () {
            var item = document.createElement('div');
            item.className = "item";
            item.innerHTML = `
              <input type="text" onclick="addChart.onAxisClick('y', ${this.yAxisCount})" class="yAxis" />
              <a class="removeAxis iconfont icon-minuscycleo"></a>
              <a onclick="addChart.addAxisY()" class="addAxis iconfont icon-pluso"></a>
            `
            $('#addChartModal .modal-body .controls-content')[2].append(item)
            this.yAxisCount++;
          },
          onAxisClick (type, index) {
            addChart.currentAxis = [type, index];
            var input = $('#addChartModal .modal-body .' + this.currentAxis[0] + 'Axis')[this.currentAxis[1]];
            $('#addChartModal input').forEach(v => v.className = v.className.replace(/active/g, ''));
            input.className += ' active';
          },
          changeChartType () {
            if ($('#addChartModal select')[0].value === 'pie') {
              $('#addChartModal .controls')[2].style = 'display:none';
            } else {
              $('#addChartModal .controls')[2].style = '';
            }
          },
          addAxisYCallback () {

          }
        }

    </script>
</body>
</html>