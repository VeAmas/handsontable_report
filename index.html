<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <link href="https://cdn.bootcss.com/handsontable/3.0.0/handsontable.full.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/handsontable/3.0.0/handsontable.full.js"></script>
    <script src="https://cdn.bootcss.com/echarts/4.1.0.rc2/echarts.js"></script>
    <script src="createCharts.js"></script>
</head>
<body>
    <input type="text" id="formulaEditor" style="width: 1000px">
    <div id="example"></div>
    <ul class="operate">
        <li onclick="chart && chart.create('line')">折线图</li>
        <li onclick="chart && chart.create('bar')">柱状图</li>
        <li onclick="chart && chart.create('pie')">饼图</li>
    </ul>
    <script>

        // function getCell (row, col) {
        //   report.hot.getCell(row, col)
        // }

        // function isInMerged (row, col) {
        //   var inside = false
        //   report.hot.getPlugin('mergeCells').mergedCellsCollection.mergedCells.forEach(v => {
        //     if (col >= v.col && 
        //       (col <= v.col + v.colspan - 1) &&
        //       row >= v.row &&
        //       (row <= v.row + v.rowspan - 1)) {
        //       if (col !== v.col || row !== v.row) {
        //         inside = true
        //       } else {            
        //         inside = {
        //           colspan: v.colspan,
        //           rowspan: v.rowspan
        //         };
        //       }
        //     }
        //   })
        //   return inside
        // }

        // function getMergedHead (row, col) {
        //   var mergedCells = report.hot.getPlugin('mergeCells').mergedCellsCollection.mergedCells;
        //   for (var i = 0; i < mergedCells.length; i++) {
        //     var v = mergedCells[i];
        //     if (col >= v.col && 
        //       (col <= v.col + v.colspan - 1) &&
        //       row >= v.row &&
        //       (row <= v.row + v.rowspan - 1)) {
        //       return v;
        //     }
        //   }
        // }

        /*
          option{
            skipMergedCell: 当为真时,只在非merge的单元格执行回调
          }
         */
        // function traversalSelectedCell (callback, options) {
        //   options = options || {}
        //   var selected = report.hot.getSelected();
        //   if (!selected) { return; }
        //   for (var i = 0; i < selected.length; i++) {            
        //     min = [Math.min(selected[i][0], selected[i][2]), Math.min(selected[i][1], selected[i][3])];
        //     max = [Math.max(selected[i][0], selected[i][2]), Math.max(selected[i][1], selected[i][3])];
        //     for (var row = min[0]; row <= max[0]; row++) {
        //       for (var col = min[1]; col <= max[1]; col++) {
        //         var param = {
        //           isTop: row === min[0],
        //           isRight: col === max[1],
        //           isBottom: row === max[0],
        //           isLeft: col === min[1]
        //         }
        //         if (options.skipMergedCell) {
        //           var inside = isInMerged(row, col)
        //           if (!inside) {
        //             callback(row, col, param);
        //           } else if (inside.rowspan) {
        //             param.merged = true;
        //             param.rowspan = inside.rowspan;
        //             param.colspan = inside.colspan;
        //             param.isRight = col + inside.colspan - 1 === max[1];
        //             param.isBottom = row + inside.rowspan - 1 === max[0];
        //             callback(row, col, param);
        //           }
        //         } else {
        //           callback(row, col, param);
        //         }
        //       }
        //     }
        //   }
        // }

        // function setStyle (style) {
        //   traversalSelectedCell(function (row, col) {
        //     if (!report.styleList[row + ',' + col]) { report.styleList[row + ',' + col] = {}; }
            
        //     for (var key in style) {
        //       report.styleList[row + ',' + col][key] = style[key]
        //     }
        //   })
        //   report.hot.render();
        // }

        /*
          border: {
            color,
            type: 0无边框 1上 2右 3下 4左 5周围一圈 6全部
          }
         */
        // function setBorder (border) {
        //   function hasStyle (row, col) {
        //     if (!report.styleList[row + ',' + col]) { report.styleList[row + ',' + col] = {}; }
        //     return true;
        //   }

        //   function setMergedBorder (row, col, css, color) {
        //     var inside = isInMerged(row, col);
        //     if (inside === true) {
        //       var mergedHead = getMergedHead(row, col);
        //       row = mergedHead.row;
        //       col = mergedHead.col;
        //     } 

        //     if (color) {
        //       hasStyle(row, col);
        //       report.styleList[row + ',' + col][css] = color
        //     } else if (report.styleList[row + ',' + col]) {
        //       delete report.styleList[row + ',' + col][css]
        //     }
        //   }

        //   if (report.hot.getSelected().length > 1) { return; }
        //   traversalSelectedCell(function (row, col, param) {
        //     if (border.type === 0 || border.type === 6) {
        //       if (param.isTop && row > 0 && (border.type === 0 ? report.styleList[(row - 1) + ',' + col] : hasStyle((row - 1), col))) {
        //         setMergedBorder(row - 1, col, 'borderBottomColor', border.type === 6 && border.color);
        //       }
        //       if (param.isLeft && col > 0 && (border.type === 0 ? report.styleList[row + ',' + (col - 1)] : hasStyle(row, col - 1))) {
        //         setMergedBorder(row, col - 1, 'borderRightColor', border.type === 6 && border.color);
        //       }
        //       if ((col === 0 || row === 0) && (border.type === 0 ? report.styleList[row + ',' + col] : hasStyle(row, col))) {
        //         if (border.type === 0) {
        //           delete report.styleList[row + ',' + col].borderTopColor
        //           delete report.styleList[row + ',' + col].borderLeftColor
        //         } else {
        //           report.styleList[row + ',' + col].borderTopColor = border.color
        //           report.styleList[row + ',' + col].borderLeftColor = border.color
        //         }
        //       }
        //       if (border.type === 0 ? report.styleList[row + ',' + col] : hasStyle(row, col)) {
        //         if (border.type === 0) {
        //           delete report.styleList[row + ',' + col].borderRightColor
        //           delete report.styleList[row + ',' + col].borderBottomColor
        //         } else {
        //           report.styleList[row + ',' + col].borderRightColor = border.color
        //           report.styleList[row + ',' + col].borderBottomColor = border.color
        //         }
        //       }
        //     }
        //     else {
        //         if ((border.type === 1 || border.type === 5) && param.isTop) {
        //             for (var i = 0; i < (param.colspan || 1); i++) {
        //               if (row > 0) {
        //                   setMergedBorder(row - 1, (col + i), 'borderBottomColor', border.color);
        //               } else {
        //                   hasStyle(row, (col + i))
        //                   report.styleList[row + ',' + (col + i)].borderTopColor = border.color
        //               }
        //             }
        //         }
        //         if ((border.type === 2 || border.type === 5) && param.isRight) {
        //           hasStyle(row, col)
        //           report.styleList[row + ',' + col].borderRightColor = border.color
        //         }
        //         if ((border.type === 3 || border.type === 5) && param.isBottom) {
        //           hasStyle(row, col)
        //           report.styleList[row + ',' + col].borderBottomColor = border.color
        //         }
        //         if ((border.type === 4 || border.type === 5) && param.isLeft) {
        //             for (var i = 0; i < (param.rowspan || 1); i++) {
        //               if (col > 0) {
        //                   setMergedBorder((row + i), col - 1, 'borderRightColor', border.color);
        //               } else {
        //                   hasStyle((row + i), col)
        //                   report.styleList[(row + i) + ',' + col].borderLeftColor = border.color
        //               }
        //             }
        //         }
        //     }
        //   }, {skipMergedCell: true})
        //   report.hot.render();
        // }

        // function fillEmptyData (data, width, height) {
        //   data = data.concat(new Array(height).join('.').split('.').map(v => []).slice(0, height));
        //   return data;
        // }

        // function arrayTrim (data) {
        //   var hasDataToken = false;
        //   for (var i = data.length - 1; i >= 0; i--) {
        //     if (data[i].some(v => v)) { 
        //       hasDataToken = true;
        //       for (var j = data[i].length - 1; j > 0; j--) {
        //         if (data[i][j]) { break; }
        //         data[i].splice(j, 1);
        //       }
        //       continue; 
        //     }
        //     if (hasDataToken) {
        //       data[i].length = 0;
        //     } else {
        //       data.length --;
        //     }
        //   }
        // }

        // function getFormulas (array) {
        //   var formulaList = [];
        //   array.forEach((v, i) => {
        //     v.forEach((u, j) => {
        //       if (/^{{=.*}}$/.test(u)) {
        //         var rawFormula = u.match(/^{{=(.*)}}$/)[1];
        //         if (/^\$\(.*\)$/.test(rawFormula)) {
        //           formulaList.push([i + ',' + j, 'GET', rawFormula.match(/^\$\((.*)\)$/)[1] ]);
        //         } else if (/^SUM\(.*\)$/.test(rawFormula)) {
        //           formulaList.push([i + ',' + j, 'SUM', ...rawFormula.match(/^SUM\((.*)\)$/)[1].split(',')])
        //         } else if (/^MAX\(.*\)$/.test(rawFormula)) {
        //           formulaList.push([i + ',' + j, 'MAX', ...rawFormula.match(/^MAX\((.*)\)$/)[1].split(',')])
        //         }
        //       }
        //     })
        //   })

        //   return formulaList;
        // }

        // function getParamList (formulaList) {
        //   var paramList = [];
        //   formulaList.forEach(v => {
        //     v.slice(2).forEach(u => {
        //       if (!/^[A-Z]{1,}[0-9]{1,}$/.test(u)) {
        //         paramList.push(u)
        //       }
        //     })
        //   })
        //   return paramList;
        // }

        // function cartesianToExcelCoord (row, col) {
        //   function mod26 (num) {
        //     return num % 26 === 0 ? 26 : num % 26;
        //   }
        //   row += 1;
        //   col += 1;
        //   var _col = '';
        //   while (col) {
        //     _col = String.fromCharCode(mod26(col) + 64) + _col;
        //     col = (col - mod26(col)) / 26
        //   }
        //   return _col + row;
        // }

        // function getSelectedCellCoord () {
        //   var coordList = [];
        //   traversalSelectedCell(function (row, col) {
        //     var coord = cartesianToExcelCoord(row, col);
        //     coordList.push(coord);
        //   }, {skipMergedCell: true})
        //   document.getElementById('formulaEditor').value = coordList.join(',');
        // }

        // function save () {
        //   var {tableWidth, tableHeight, tabelHeaderHeight, styleList, customColWidth, customRowWidth} = report;
        //   var saveData = {tableWidth, tableHeight, tabelHeaderHeight, styleList, customColWidth, customRowWidth};

        //   saveData.mergeCells = report.hot.getPlugin('mergeCells').mergedCellsCollection.mergedCells;
        //   saveData.mergeCells = saveData.mergeCells.map(v => ({
        //     col: v.col,
        //     colspan: v.colspan,
        //     row: v.row,
        //     rowspan: v.rowspan
        //   }));

        //   saveData.tableHeaderData = tabelHeaderHeight > 0 ? report.hot.getData(0, 0, tabelHeaderHeight - 1, tableWidth - 1) : [];
        //   saveData.tableBodyData = report.hot.getData(tabelHeaderHeight, 0, tableHeight - 1, tableWidth - 1);
          
        //   arrayTrim(saveData.tableHeaderData);
        //   arrayTrim(saveData.tableBodyData);

        //   saveData.formulaList = getFormulas(saveData.tableBodyData);
        //   saveData.paramList = getParamList(saveData.formulaList);

        //   saveData.customRowHeight = [];
        //   saveData.customColWidth = [];
        //   for (var i = 0; i < saveData.tableHeight; i++) {
        //     var height = report.hot.getRowHeight(i);
        //     if (height !== 23) {
        //       saveData.customRowHeight.push([i, height])
        //     }
        //   }
        //   for (i = 0; i < saveData.tableWidth; i++) {
        //     var width = report.hot.getColWidth(i)
        //     if (width !== 105) {
        //       saveData.customColWidth.push([i, width])
        //     }
        //   }


        //   localStorage.setItem('report', JSON.stringify(saveData))
        // }

        // function load () {
        //   var report = JSON.parse(localStorage.getItem('report'));
        //   report = Object.assign({
        //     tableWidth: 26,
        //     tableHeight: 100,
        //     tabelHeaderHeight: 0,
        //     tableHeaderData: [],
        //     tableBodyData: [],
        //     styleList: {},
        //     customRowHeight: [],
        //     customColWidth: [],
        //     formulaList: [],
        //     paramList: [],
        //     mergeCells: [],
        //   }, report || {})

        //   var hot = Handsontable(document.getElementById('example'), {
        //     data: fillEmptyData(report.tableHeaderData.concat(report.tableBodyData), report.tableWidth, report.tableHeight),
        //     height: 456,
        //     colWidths: new Array(report.tableWidth).join('.').split('.').map((v, i) => { var item = report.customColWidth.find(u => u[0] === i); return item ? item[1] : 105 }),
        //     rowHeights: new Array(report.tableHeight).join('.').split('.').map((v, i) => { var item = report.customRowHeight.find(u => u[0] === i); return item ? item[1] : 23 }),
        //     minCols: report.tableWidth,
        //     minRows: report.tableHeight,
        //     rowHeaders: true,
        //     colHeaders: true,
        //     filters: true,
        //     dropdownMenu: true,
        //     contextMenu: {
        //       callback: function (key, options) {
        //         if (key === 'about') {

        //         }
        //       },
        //       items: {
        //         row_above: {},
        //         row_below: {},
        //         hsep1: '---------',
        //         col_left: {},
        //         col_right: {},
        //         hsep2: '---------',
        //         remove_row: {},
        //         remove_col: {},
        //         hsep3: '---------',
        //         undo: {},
        //         redo: {},
        //         make_read_only: {},
        //         mergeCells: {},
        //         about: {name: 'about'}
        //       }
        //     },
        //     autoRowSize: true,
        //     manualColumnMove: true,
        //     manualRowMove: true,
        //     manualColumnResize: true,
        //     mergeCells: report.mergeCells,
        //     manualRowResize: true,
        //     fillHandle: {
        //       autoInsertRow: false,
        //     },
        //     cells: function(row, column) {
        //       var cellMeta = {};
        //         function getStyle (row, col, styleName) {
        //           return report.styleList[row + ',' + col] && report.styleList[row + ',' + col][styleName]
        //         }
        //         cellMeta.renderer = function(hotInstance, TD, row, col, prop, value) {
        //           TD.style.color = getStyle(row, col, 'color') || '#000';
        //           TD.style.backgroundColor = getStyle(row, col, 'background') || '#fff';
        //           TD.style.fontSize = getStyle(row, col, 'fontSize') || '14px';
        //           TD.style.borderTopColor = getStyle(row, col, 'borderTopColor') || ""
        //           TD.style.borderLeftColor = getStyle(row, col, 'borderLeftColor') || ""
        //           TD.style.borderBottomColor = getStyle(row, col, 'borderBottomColor') || ""
        //           TD.style.borderRightColor = getStyle(row, col, 'borderRightColor') || ""
        //           TD.textContent = value;
        //         };


        //       return cellMeta;
        //     },
        //     afterSelection: function (r, c, r2, c2, preventScrolling, selectionLayerLevel) {
        //       // console.log(r, c, r2, c2, preventScrolling, selectionLayerLevel);
        //       getSelectedCellCoord();
        //     }
        //   });

        //   report.hot = hot;
        //   return report;
        // }

        // var report = load();

        function ReportEditor () {          
          this.tableWidth = 26
          this.tableHeight = 100
          this.tabelHeaderHeight = 0
          this.tableHeaderData = []
          this.tableBodyData = []
          this.styleList = {}
          this.customRowHeight = []
          this.customColWidth = []
          this.formulaList = []
          this.paramList = []
          this.mergeCells = []
          this.cellReference = []
        }
        ReportEditor.prototype = {
          getCell (row, col) {
            return this.hot.getCell(row, col)
          },
          isInMerged (row, col) {
            var inside = false
            this.hot.getPlugin('mergeCells').mergedCellsCollection.mergedCells.forEach(v => {
              if (col >= v.col && 
                (col <= v.col + v.colspan - 1) &&
                row >= v.row &&
                (row <= v.row + v.rowspan - 1)) {
                if (col !== v.col || row !== v.row) {
                  inside = true
                } else {            
                  inside = {
                    colspan: v.colspan,
                    rowspan: v.rowspan
                  };
                }
              }
            })
            return inside
          },
          getMergedHead (row, col) {
            var mergedCells = this.hot.getPlugin('mergeCells').mergedCellsCollection.mergedCells;
            for (var i = 0; i < mergedCells.length; i++) {
              var v = mergedCells[i];
              if (col >= v.col && 
                (col <= v.col + v.colspan - 1) &&
                row >= v.row &&
                (row <= v.row + v.rowspan - 1)) {
                return v;
              }
            }
          },
          /* option{
               skipMergedCell: 当为真时,只在非merge的单元格执行回调
             } */
          traversalSelectedCell (callback, options) {
            options = options || {}
            var selected = this.hot.getSelected();
            if (!selected) { return; }
            for (var i = 0; i < selected.length; i++) {            
              min = [Math.min(selected[i][0], selected[i][2]), Math.min(selected[i][1], selected[i][3])];
              max = [Math.max(selected[i][0], selected[i][2]), Math.max(selected[i][1], selected[i][3])];
              for (var row = min[0]; row <= max[0]; row++) {
                for (var col = min[1]; col <= max[1]; col++) {
                  var param = {
                    isTop: row === min[0],
                    isRight: col === max[1],
                    isBottom: row === max[0],
                    isLeft: col === min[1]
                  }
                  if (options.skipMergedCell) {
                    var inside = this.isInMerged(row, col)
                    if (!inside) {
                      callback(row, col, param);
                    } else if (inside.rowspan) {
                      param.merged = true;
                      param.rowspan = inside.rowspan;
                      param.colspan = inside.colspan;
                      param.isRight = col + inside.colspan - 1 === max[1];
                      param.isBottom = row + inside.rowspan - 1 === max[0];
                      callback(row, col, param);
                    }
                  } else {
                    callback(row, col, param);
                  }
                }
              }
            }
          },
          setStyle (style) {
            this.traversalSelectedCell((row, col) => {
              if (!this.styleList[row + ',' + col]) { this.styleList[row + ',' + col] = {}; }
              
              for (var key in style) {
                this.styleList[row + ',' + col][key] = style[key]
              }
            })
            this.hot.render();
          },
          setBorder (border) {
            var hasStyle = (row, col) => {
              if (!this.styleList[row + ',' + col]) { this.styleList[row + ',' + col] = {}; }
              return true;
            }

            var setMergedBorder = (row, col, css, color) => {
              var inside = this.isInMerged(row, col);
              if (inside === true) {
                var mergedHead = this.getMergedHead(row, col);
                row = mergedHead.row;
                col = mergedHead.col;
              } 

              if (color) {
                hasStyle(row, col);
                this.styleList[row + ',' + col][css] = color
              } else if (this.styleList[row + ',' + col]) {
                delete this.styleList[row + ',' + col][css]
              }
            }

            if (this.hot.getSelected().length > 1) { return; }
            this.traversalSelectedCell((row, col, param) => {
              if (border.type === 0 || border.type === 6) {
                if (param.isTop && row > 0 && (border.type === 0 ? this.styleList[(row - 1) + ',' + col] : hasStyle((row - 1), col))) {
                  setMergedBorder(row - 1, col, 'borderBottomColor', border.type === 6 && border.color);
                }
                if (param.isLeft && col > 0 && (border.type === 0 ? this.styleList[row + ',' + (col - 1)] : hasStyle(row, col - 1))) {
                  setMergedBorder(row, col - 1, 'borderRightColor', border.type === 6 && border.color);
                }
                if ((col === 0 || row === 0) && (border.type === 0 ? this.styleList[row + ',' + col] : hasStyle(row, col))) {
                  if (border.type === 0) {
                    delete this.styleList[row + ',' + col].borderTopColor
                    delete this.styleList[row + ',' + col].borderLeftColor
                  } else {
                    this.styleList[row + ',' + col].borderTopColor = border.color
                    this.styleList[row + ',' + col].borderLeftColor = border.color
                  }
                }
                if (border.type === 0 ? this.styleList[row + ',' + col] : hasStyle(row, col)) {
                  if (border.type === 0) {
                    delete this.styleList[row + ',' + col].borderRightColor
                    delete this.styleList[row + ',' + col].borderBottomColor
                  } else {
                    this.styleList[row + ',' + col].borderRightColor = border.color
                    this.styleList[row + ',' + col].borderBottomColor = border.color
                  }
                }
              }
              else {
                  if ((border.type === 1 || border.type === 5) && param.isTop) {
                      for (var i = 0; i < (param.colspan || 1); i++) {
                        if (row > 0) {
                            setMergedBorder(row - 1, (col + i), 'borderBottomColor', border.color);
                        } else {
                            hasStyle(row, (col + i))
                            this.styleList[row + ',' + (col + i)].borderTopColor = border.color
                        }
                      }
                  }
                  if ((border.type === 2 || border.type === 5) && param.isRight) {
                    hasStyle(row, col)
                    this.styleList[row + ',' + col].borderRightColor = border.color
                  }
                  if ((border.type === 3 || border.type === 5) && param.isBottom) {
                    hasStyle(row, col)
                    this.styleList[row + ',' + col].borderBottomColor = border.color
                  }
                  if ((border.type === 4 || border.type === 5) && param.isLeft) {
                      for (var i = 0; i < (param.rowspan || 1); i++) {
                        if (col > 0) {
                            setMergedBorder((row + i), col - 1, 'borderRightColor', border.color);
                        } else {
                            hasStyle((row + i), col)
                            this.styleList[(row + i) + ',' + col].borderLeftColor = border.color
                        }
                      }
                  }
              }
            }, {skipMergedCell: true})
            this.hot.render();
          },
          fillEmptyData (data, width, height) {
            data = data.concat(new Array(height).join('.').split('.').map(v => []).slice(0, height));
            return data;
          },
          arrayTrim (data) {
            var hasDataToken = false;
            for (var i = data.length - 1; i >= 0; i--) {
              if (data[i].some(v => v)) { 
                hasDataToken = true;
                for (var j = data[i].length - 1; j > 0; j--) {
                  if (data[i][j]) { break; }
                  data[i].splice(j, 1);
                }
                continue; 
              }
              if (hasDataToken) {
                data[i].length = 0;
              } else {
                data.length --;
              }
            }
          },
          getFormulas (array) {
            var formulaList = [];
            array.forEach((v, i) => {
              v.forEach((u, j) => {
                if (/^{{=.*}}$/.test(u)) {
                  var rawFormula = u.match(/^{{=(.*)}}$/)[1];
                  if (/^\$\(.*\)$/.test(rawFormula)) {
                    formulaList.push([i + ',' + j, 'GET', rawFormula.match(/^\$\((.*)\)$/)[1] ]);
                  } else if (/^SUM\(.*\)$/.test(rawFormula)) {
                    formulaList.push([i + ',' + j, 'SUM', ...rawFormula.match(/^SUM\((.*)\)$/)[1].split(',')])
                  } else if (/^MAX\(.*\)$/.test(rawFormula)) {
                    formulaList.push([i + ',' + j, 'MAX', ...rawFormula.match(/^MAX\((.*)\)$/)[1].split(',')])
                  }
                }
              })
            })
            return formulaList;
          },
          getParamList (formulaList) {
            var paramList = [];
            formulaList.forEach(v => {
              v.slice(2).forEach(u => {
                if (!/^[A-Z]{1,}[0-9]{1,}$/.test(u)) {
                  paramList.push(u)
                }
              })
            })
            return paramList;
          },
          cartesianToExcelCoord (row, col) {
            function mod26 (num) {
              return num % 26 === 0 ? 26 : num % 26;
            }
            row += 1;
            col += 1;
            var _col = '';
            while (col) {
              _col = String.fromCharCode(mod26(col) + 64) + _col;
              col = (col - mod26(col)) / 26
            }
            return _col + row;
          },
          excelCoordToCartesian (coord) {
            var col = coord.match(/[A-Z]{1,}/)[0];
            col = col.split('').map(v => v.charCodeAt() - 64).reduce((o, n) => o * 26 + n, 0) - 1
            var row = +coord.match(/[0-9]{1,}/)[0] - 1
            return [row, col]
          },
          getSelectedCellCoord () {
            var coordList = [];
            this.traversalSelectedCell((row, col) => {
              var coord = this.cartesianToExcelCoord(row, col);
              coordList.push(coord);
            }, {skipMergedCell: true})
            document.getElementById('formulaEditor').value = coordList.join(',');
          },
          checkReference () {
            var selected = this.hot.getSelected()[0];

            if (!selected) { return; }
            var data = this.hot.getData(selected[0], selected[1], selected[0], selected[1])[0][0]
            var coords = data.match(/[A-Z]+[0-9]+/g);
            this.cellReference = coords ? coords.map(v => this.excelCoordToCartesian(v)) : [];
            this.hot.render();
          },
          save () {
            var {tableWidth, tableHeight, tabelHeaderHeight, styleList, customColWidth, customRowWidth} = this;
            var saveData = {tableWidth, tableHeight, tabelHeaderHeight, styleList, customColWidth, customRowWidth};

            saveData.mergeCells = this.hot.getPlugin('mergeCells').mergedCellsCollection.mergedCells;
            saveData.mergeCells = saveData.mergeCells.map(v => ({
              col: v.col,
              colspan: v.colspan,
              row: v.row,
              rowspan: v.rowspan
            }));

            saveData.tableHeaderData = tabelHeaderHeight > 0 ? this.hot.getData(0, 0, tabelHeaderHeight - 1, tableWidth - 1) : [];
            saveData.tableBodyData = this.hot.getData(tabelHeaderHeight, 0, tableHeight - 1, tableWidth - 1);
            
            this.arrayTrim(saveData.tableHeaderData);
            this.arrayTrim(saveData.tableBodyData);

            saveData.formulaList = this.getFormulas(saveData.tableBodyData);
            saveData.paramList = this.getParamList(saveData.formulaList);

            saveData.customRowHeight = [];
            saveData.customColWidth = [];
            for (var i = 0; i < saveData.tableHeight; i++) {
              var height = this.hot.getRowHeight(i);
              if (height !== 23) {
                saveData.customRowHeight.push([i, height])
              }
            }
            for (i = 0; i < saveData.tableWidth; i++) {
              var width = this.hot.getColWidth(i)
              if (width !== 105) {
                saveData.customColWidth.push([i, width])
              }
            }


            localStorage.setItem('report', JSON.stringify(saveData))
          },          
          load () {
            var report = JSON.parse(localStorage.getItem('report'));
            Object.assign(this, report || {})

            this.hot = Handsontable(document.getElementById('example'), {
              data: this.fillEmptyData(this.tableHeaderData.concat(this.tableBodyData), this.tableWidth, this.tableHeight),
              height: 456,
              colWidths: new Array(this.tableWidth).join('.').split('.').map((v, i) => { var item = this.customColWidth.find(u => u[0] === i); return item ? item[1] : 105 }),
              rowHeights: new Array(this.tableHeight).join('.').split('.').map((v, i) => { var item = this.customRowHeight.find(u => u[0] === i); return item ? item[1] : 23 }),
              minCols: this.tableWidth,
              minRows: this.tableHeight,
              rowHeaders: true,
              colHeaders: true,
              filters: true,
              dropdownMenu: true,
              contextMenu: {
                callback: function (key, options) {
                  if (key === 'about') {

                  }
                },
                items: {
                  row_above: {},
                  row_below: {},
                  hsep1: '---------',
                  col_left: {},
                  col_right: {},
                  hsep2: '---------',
                  remove_row: {},
                  remove_col: {},
                  hsep3: '---------',
                  undo: {},
                  redo: {},
                  make_read_only: {},
                  mergeCells: {},
                  about: {name: 'about'}
                }
              },
              autoRowSize: true,
              manualColumnMove: true,
              manualRowMove: true,
              manualColumnResize: true,
              mergeCells: this.mergeCells,
              manualRowResize: true,
              fillHandle: {
                autoInsertRow: false,
              },
              cells: (row, column) => {
                var cellMeta = {};
                  var getStyle = (row, col, styleName) => {
                    return this.styleList[row + ',' + col] && this.styleList[row + ',' + col][styleName]
                  }
                  cellMeta.renderer = (hotInstance, TD, row, col, prop, value) => {
                    TD.style.color = getStyle(row, col, 'color') || '#000';
                    TD.style.backgroundColor = getStyle(row, col, 'background') || '#fff';
                    TD.style.fontSize = getStyle(row, col, 'fontSize') || '14px';
                    TD.style.borderTopColor = getStyle(row, col, 'borderTopColor') || ""
                    TD.style.borderLeftColor = getStyle(row, col, 'borderLeftColor') || ""
                    TD.style.borderBottomColor = getStyle(row, col, 'borderBottomColor') || ""
                    TD.style.borderRightColor = getStyle(row, col, 'borderRightColor') || ""

                    if (this.cellReference) {
                      if (this.cellReference.find(v => (v[0] === row && v[1] === col))) {
                        TD.style.backgroundColor = 'red';
                      }
                    }
                    TD.textContent = value;
                  };


                return cellMeta;
              },
              afterSelection: (r, c, r2, c2, preventScrolling, selectionLayerLevel) => {
                // console.log(r, c, r2, c2, preventScrolling, selectionLayerLevel);
                this.getSelectedCellCoord();
              }
            });
          }
        }

        var reportEditor = new ReportEditor();
        reportEditor.load();

    </script>
</body>
</html>