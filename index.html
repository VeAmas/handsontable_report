<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <link href="https://cdn.bootcss.com/handsontable/3.0.0/handsontable.full.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/handsontable/3.0.0/handsontable.full.js"></script>
    <script src="https://cdn.bootcss.com/echarts/4.1.0.rc2/echarts.js"></script>
    <script src="createCharts.js"></script>
    <script src="shunting-yard-algorithm.js"></script>
    <style>
      .ht_master tr > td {
        white-space: nowrap;
        overflow: hidden;
      }

    </style>
</head>
<body>
    <input type="text" id="formulaEditor" style="width: 1000px">
    <div id="example"></div>
    <ul class="operate">
        <li onclick="chart && chart.create('line')">折线图</li>
        <li onclick="chart && chart.create('bar')">柱状图</li>
        <li onclick="chart && chart.create('pie')">饼图</li>
    </ul>
    <script>
        function ReportEditor () {          
          this.tableWidth = 26
          this.tableHeight = 100
          this.tabelHeaderHeight = 0
          this.tableHeaderData = []
          this.tableBodyData = []
          this.styleList = {}
          this.customRowHeight = []
          this.customColWidth = []
          this.formulaList = []
          this.paramList = []
          this.mergeCells = []
          this.cellReference = []
        }
        ReportEditor.prototype = {
          getCell (row, col) {
            return this.hot.getCell(row, col)
          },
          isInMerged (row, col) {
            var inside = false
            this.hot.getPlugin('mergeCells').mergedCellsCollection.mergedCells.forEach(v => {
              if (col >= v.col && 
                (col <= v.col + v.colspan - 1) &&
                row >= v.row &&
                (row <= v.row + v.rowspan - 1)) {
                if (col !== v.col || row !== v.row) {
                  inside = true
                } else {            
                  inside = {
                    colspan: v.colspan,
                    rowspan: v.rowspan
                  };
                }
              }
            })
            return inside
          },
          getMergedHead (row, col) {
            var mergedCells = this.hot.getPlugin('mergeCells').mergedCellsCollection.mergedCells;
            for (var i = 0; i < mergedCells.length; i++) {
              var v = mergedCells[i];
              if (col >= v.col && 
                (col <= v.col + v.colspan - 1) &&
                row >= v.row &&
                (row <= v.row + v.rowspan - 1)) {
                return v;
              }
            }
          },
          /* option{
               skipMergedCell: 当为真时,只在非merge的单元格执行回调
             } */
          traversalSelectedCell (callback, options) {
            options = options || {}
            var selected = this.hot.getSelected();
            if (!selected) { return; }
            for (var i = 0; i < selected.length; i++) {            
              min = [Math.min(selected[i][0], selected[i][2]), Math.min(selected[i][1], selected[i][3])];
              max = [Math.max(selected[i][0], selected[i][2]), Math.max(selected[i][1], selected[i][3])];
              for (var row = min[0]; row <= max[0]; row++) {
                for (var col = min[1]; col <= max[1]; col++) {
                  var param = {
                    isTop: row === min[0],
                    isRight: col === max[1],
                    isBottom: row === max[0],
                    isLeft: col === min[1]
                  }
                  if (options.skipMergedCell) {
                    var inside = this.isInMerged(row, col)
                    if (!inside) {
                      callback(row, col, param);
                    } else if (inside.rowspan) {
                      param.merged = true;
                      param.rowspan = inside.rowspan;
                      param.colspan = inside.colspan;
                      param.isRight = col + inside.colspan - 1 === max[1];
                      param.isBottom = row + inside.rowspan - 1 === max[0];
                      callback(row, col, param);
                    }
                  } else {
                    callback(row, col, param);
                  }
                }
              }
            }
          },
          setStyle (style) {
            this.traversalSelectedCell((row, col) => {
              if (!this.styleList[row + ',' + col]) { this.styleList[row + ',' + col] = {}; }
              
              for (var key in style) {
                this.styleList[row + ',' + col][key] = style[key]
              }
            })
            this.hot.render();
          },
          setBorder (border) {
            var hasStyle = (row, col) => {
              if (!this.styleList[row + ',' + col]) { this.styleList[row + ',' + col] = {}; }
              return true;
            }

            var setMergedBorder = (row, col, css, color) => {
              var inside = this.isInMerged(row, col);
              if (inside === true) {
                var mergedHead = this.getMergedHead(row, col);
                row = mergedHead.row;
                col = mergedHead.col;
              } 

              if (color) {
                hasStyle(row, col);
                this.styleList[row + ',' + col][css] = color
              } else if (this.styleList[row + ',' + col]) {
                delete this.styleList[row + ',' + col][css]
              }
            }

            if (this.hot.getSelected().length > 1) { return; }
            this.traversalSelectedCell((row, col, param) => {
              if (border.type === 0 || border.type === 6) {
                if (param.isTop && row > 0 && (border.type === 0 ? this.styleList[(row - 1) + ',' + col] : hasStyle((row - 1), col))) {
                  setMergedBorder(row - 1, col, 'borderBottomColor', border.type === 6 && border.color);
                }
                if (param.isLeft && col > 0 && (border.type === 0 ? this.styleList[row + ',' + (col - 1)] : hasStyle(row, col - 1))) {
                  setMergedBorder(row, col - 1, 'borderRightColor', border.type === 6 && border.color);
                }
                if ((col === 0 || row === 0) && (border.type === 0 ? this.styleList[row + ',' + col] : hasStyle(row, col))) {
                  if (border.type === 0) {
                    delete this.styleList[row + ',' + col].borderTopColor
                    delete this.styleList[row + ',' + col].borderLeftColor
                  } else {
                    this.styleList[row + ',' + col].borderTopColor = border.color
                    this.styleList[row + ',' + col].borderLeftColor = border.color
                  }
                }
                if (border.type === 0 ? this.styleList[row + ',' + col] : hasStyle(row, col)) {
                  if (border.type === 0) {
                    delete this.styleList[row + ',' + col].borderRightColor
                    delete this.styleList[row + ',' + col].borderBottomColor
                  } else {
                    this.styleList[row + ',' + col].borderRightColor = border.color
                    this.styleList[row + ',' + col].borderBottomColor = border.color
                  }
                }
              }
              else {
                  if ((border.type === 1 || border.type === 5) && param.isTop) {
                      for (var i = 0; i < (param.colspan || 1); i++) {
                        if (row > 0) {
                            setMergedBorder(row - 1, (col + i), 'borderBottomColor', border.color);
                        } else {
                            hasStyle(row, (col + i))
                            this.styleList[row + ',' + (col + i)].borderTopColor = border.color
                        }
                      }
                  }
                  if ((border.type === 2 || border.type === 5) && param.isRight) {
                    hasStyle(row, col)
                    this.styleList[row + ',' + col].borderRightColor = border.color
                  }
                  if ((border.type === 3 || border.type === 5) && param.isBottom) {
                    hasStyle(row, col)
                    this.styleList[row + ',' + col].borderBottomColor = border.color
                  }
                  if ((border.type === 4 || border.type === 5) && param.isLeft) {
                      for (var i = 0; i < (param.rowspan || 1); i++) {
                        if (col > 0) {
                            setMergedBorder((row + i), col - 1, 'borderRightColor', border.color);
                        } else {
                            hasStyle((row + i), col)
                            this.styleList[(row + i) + ',' + col].borderLeftColor = border.color
                        }
                      }
                  }
              }
            }, {skipMergedCell: true})
            this.hot.render();
          },
          fillEmptyData (data, width, height) {
            data = data.concat(new Array(height).join('.').split('.').map(v => []).slice(0, height));
            return data;
          },
          arrayTrim (data) {
            var hasDataToken = false;
            for (var i = data.length - 1; i >= 0; i--) {
              if (data[i].some(v => v)) { 
                hasDataToken = true;
                for (var j = data[i].length - 1; j > 0; j--) {
                  if (data[i][j]) { break; }
                  data[i].splice(j, 1);
                }
                continue; 
              }
              if (hasDataToken) {
                data[i].length = 0;
              } else {
                data.length --;
              }
            }
          },
          getFormulas (array) {
            var formulaList = [];
            array.forEach((v, i) => {
              v.forEach((u, j) => {
                if (/^{{=.*}}$/.test(u)) {
                  var rawFormula = u.match(/^{{=(.*)}}$/)[1];
                  formulaList.push({pos: i + ',' + j, formula: sya(rawFormula)});
                }
              })
            })
            return formulaList;
          },
          getParamList (formulaList) {
            var paramList = [];
            formulaList.forEach(v => {
              v.formula.forEach(u => {
                if (u.type === 'e') {
                  paramList.push(u.value)
                }
              })
            })
            return paramList;
          },
          cartesianToExcelCoord (row, col) {
            function mod26 (num) {
              return num % 26 === 0 ? 26 : num % 26;
            }
            row += 1;
            col += 1;
            var _col = '';
            while (col) {
              _col = String.fromCharCode(mod26(col) + 64) + _col;
              col = (col - mod26(col)) / 26
            }
            return _col + row;
          },
          excelCoordToCartesian (coord) {
            var col = coord.match(/[A-Z]{1,}/)[0];
            col = col.split('').map(v => v.charCodeAt() - 64).reduce((o, n) => o * 26 + n, 0) - 1
            var row = +coord.match(/[0-9]{1,}/)[0] - 1
            return [row, col]
          },
          getSelectedCellCoord () {
            var coordList = [];
            this.traversalSelectedCell((row, col) => {
              var coord = this.cartesianToExcelCoord(row, col);
              coordList.push(coord);
            }, {skipMergedCell: true})
            document.getElementById('formulaEditor').value = coordList.join(',');
          },
          checkReference () {
            var selected = this.hot.getSelected()[0];

            if (!selected) { return; }
            var data = this.hot.getData(selected[0], selected[1], selected[0], selected[1])[0][0]
            var coords = data.match(/[A-Z]+[0-9]+/g);
            this.cellReference = coords ? coords.map(v => this.excelCoordToCartesian(v)) : [];
            this.hot.render();
          },
          getReferenceCellsList (data) {
            var referenceCellsList = []
            data.forEach((v, row) => {
              v && v.forEach((u, col) => {
                if (!/^{{=.*}}$/.test(u)) { return; }
                u = u.replace(/\$\([\s\S]*?\)/g, '');
                var cells = u.match(/[A-Z]+[0-9]+/g);
                if (cells) {
                    referenceCellsList.push({
                        name: this.cartesianToExcelCoord(row, col),
                        children: cells
                    })
                }
              })
            })
            return referenceCellsList;
          },
          depthFirstSearch (list) {
            var listReserved = Object.assign([], list);
            var stack = [];
            var queue = [];
            while (list.some(v => !v.visited)) {
              var firstNode = list.find(v => !v.visited);
              stack.push(firstNode);

              while (stack.length > 0) {
                var curNode = stack.pop();
                if (!curNode) {
                  queue.pop();
                  continue;
                }
                stack.push(null);
                var index = queue.indexOf(curNode);
                queue.push(curNode);
                if (index > -1) {
                  console.error('有闭环:' + queue.filter((v, i) => i >= index).map(v => v.name).join('->'));
                  return false;
                }
                curNode.visited = true;
                if (curNode.children) {
                  var children = curNode.children.map(v => list.find(u => u.name === v)).filter(v => v);
                  if (children.length > 0) {
                    stack = stack.concat(children)
                  }            
                }
              }
            }
            return true;
          },    
          topoSort (list) {
            list.forEach(v => v.out = []);
            list.forEach(v => {
              var children = v.children.map(w => list.find(u => u.name === w)).filter(w => w);
              v.in = children;
              children.forEach(u => u.out.push(v))
            })

            var result = [];
            while (list.length > 0) {
              var curNode = list.find(v => v.in.length === 0)
              result.push(curNode);
              list.splice(list.indexOf(curNode), 1)
              curNode.out.forEach(v => {
                v.in.splice(v.in.indexOf(curNode), 1)
              })
            }
            return result;
          },
          save () {
            var {tableWidth, tableHeight, tabelHeaderHeight, styleList, customColWidth, customRowWidth} = this;
            var saveData = {tableWidth, tableHeight, tabelHeaderHeight, styleList, customColWidth, customRowWidth};

            saveData.mergeCells = this.hot.getPlugin('mergeCells').mergedCellsCollection.mergedCells;
            saveData.mergeCells = saveData.mergeCells.map(v => ({
              col: v.col,
              colspan: v.colspan,
              row: v.row,
              rowspan: v.rowspan
            }));

            saveData.tableHeaderData = tabelHeaderHeight > 0 ? this.hot.getData(0, 0, tabelHeaderHeight - 1, tableWidth - 1) : [];
            saveData.tableBodyData = this.hot.getData(tabelHeaderHeight, 0, tableHeight - 1, tableWidth - 1);
            
            this.arrayTrim(saveData.tableHeaderData);
            this.arrayTrim(saveData.tableBodyData);

            var referenceCellsList = this.getReferenceCellsList(Object.assign([], saveData.tableHeaderData, saveData.tableBodyData));
            if (!this.depthFirstSearch(referenceCellsList)) { return; }

            var topoSortList = this.topoSort(referenceCellsList).map(v => {
              var coord = this.excelCoordToCartesian(v.name)
              return coord[0] + ',' + coord[1];
            });

            saveData.formulaList = this.getFormulas(saveData.tableBodyData);
            saveData.paramList = this.getParamList(saveData.formulaList);

            var sortedFormula = saveData.formulaList.filter(v => topoSortList.find(u => u === v.pos));
            sortedFormula.forEach(v => {
              saveData.formulaList.splice(saveData.formulaList.indexOf(v), 1)
            })

            sortedFormula.sort((a, b) => {
                var posA = topoSortList.findIndex(v => v === a.pos);
                var posB = topoSortList.findIndex(v => v === b.pos);
                return posA - posB;
            })
            sortedFormula.forEach(w => {
              w.formula.forEach(v => {
                if (v.type !== 'c') { return; }
                var coord = this.excelCoordToCartesian(v.value)
                v.value = coord[0] + ',' + coord[1];
              })
            })
            saveData.formulaList = saveData.formulaList.concat(sortedFormula);

            saveData.customRowHeight = [];
            saveData.customColWidth = [];
            for (var i = 0; i < saveData.tableHeight; i++) {
              var height = this.hot.getRowHeight(i);
              if (height !== 23) {
                saveData.customRowHeight.push([i, height])
              }
            }
            for (i = 0; i < saveData.tableWidth; i++) {
              var width = this.hot.getColWidth(i)
              if (width !== 105) {
                saveData.customColWidth.push([i, width])
              }
            }


            localStorage.setItem('report', JSON.stringify(saveData))
          },          
          load () {
            var report = JSON.parse(localStorage.getItem('report'));
            Object.assign(this, report || {})

            this.hot = Handsontable(document.getElementById('example'), {
              data: this.fillEmptyData(this.tableHeaderData.concat(this.tableBodyData), this.tableWidth, this.tableHeight),
              height: 456,
              colWidths: new Array(this.tableWidth).join('.').split('.').map((v, i) => { var item = this.customColWidth.find(u => u[0] === i); return item ? item[1] : 105 }),
              rowHeights: new Array(this.tableHeight).join('.').split('.').map((v, i) => { var item = this.customRowHeight.find(u => u[0] === i); return item ? item[1] : 23 }),
              minCols: this.tableWidth,
              minRows: this.tableHeight,
              rowHeaders: true,
              colHeaders: true,
              filters: true,
              dropdownMenu: true,
              contextMenu: {
                callback: function (key, options) {
                  if (key === 'about') {

                  }
                },
                items: {
                  row_above: {},
                  row_below: {},
                  hsep1: '---------',
                  col_left: {},
                  col_right: {},
                  hsep2: '---------',
                  remove_row: {},
                  remove_col: {},
                  hsep3: '---------',
                  undo: {},
                  redo: {},
                  make_read_only: {},
                  mergeCells: {},
                  about: {name: 'about'}
                }
              },
              autoRowSize: true,
              manualColumnMove: true,
              manualRowMove: true,
              manualColumnResize: true,
              mergeCells: this.mergeCells,
              manualRowResize: true,
              fillHandle: {
                autoInsertRow: false,
              },
              cells: (row, column) => {
                var cellMeta = {};
                  var getStyle = (row, col, styleName) => {
                    return this.styleList[row + ',' + col] && this.styleList[row + ',' + col][styleName]
                  }
                  cellMeta.renderer = (hotInstance, TD, row, col, prop, value) => {
                    TD.style.color = getStyle(row, col, 'color') || '#000';
                    TD.style.backgroundColor = getStyle(row, col, 'background') || '#fff';
                    TD.style.fontSize = getStyle(row, col, 'fontSize') || '14px';
                    TD.style.borderTopColor = getStyle(row, col, 'borderTopColor') || ""
                    TD.style.borderLeftColor = getStyle(row, col, 'borderLeftColor') || ""
                    TD.style.borderBottomColor = getStyle(row, col, 'borderBottomColor') || ""
                    TD.style.borderRightColor = getStyle(row, col, 'borderRightColor') || ""

                    if (this.cellReference) {
                      if (this.cellReference.find(v => (v[0] === row && v[1] === col))) {
                        TD.style.backgroundColor = 'red';
                      }
                    }
                    TD.textContent = value;
                  };


                return cellMeta;
              },
              afterSelection: (r, c, r2, c2, preventScrolling, selectionLayerLevel) => {
                // console.log(r, c, r2, c2, preventScrolling, selectionLayerLevel);
                this.getSelectedCellCoord();
              }
            });
          }
        }

        var reportEditor = new ReportEditor();
        reportEditor.load();

    </script>
</body>
</html>